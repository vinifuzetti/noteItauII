{
  "name": "xml-crypto",
  "version": "0.8.4",
  "description": "Xml digital signature and encryption library for Node.js",
  "engines": {
    "node": ">=0.4.0"
  },
  "author": {
    "name": "Yaron Naveh",
    "url": "yaronn01@gmail.com, http://webservices20.blogspot.com/"
  },
  "dependencies": {
    "xmldom": "=0.1.19",
    "xpath.js": ">=0.0.3"
  },
  "devDependencies": {
    "nodeunit": ">=0.6.4"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/yaronn/xml-crypto.git"
  },
  "main": "./index.js",
  "directories": {
    "lib": "./lib"
  },
  "keywords": [
    "xml",
    "digital signature",
    "xml encryption",
    "x.509 certificate"
  ],
  "licenses": [
    {
      "type": "MIT License",
      "url": "http://www.opensource.org/licenses/mit-license.php"
    }
  ],
  "scripts": {
    "test": "nodeunit ./test/canonicalization-unit-tests.js ./test/c14nWithComments-unit-tests.js ./test/signature-unit-tests.js ./test/saml-response-test.js ./test/signature-integration-tests.js ./test/document-test.js ./test/wsfed-metadata-test.js ./test/hmac-tests.js"
  },
  "readme": "## xml-crypto\n\n[![Build Status](https://travis-ci.org/yaronn/xml-crypto.png?branch=master)](https://travis-ci.org/yaronn/xml-crypto)\n\nAn xml digital signature library for node. Xml encryption is coming soon. Written in pure javascript!\n\nFor more information visit [my blog](http://webservices20.blogspot.com/) or [my twitter](https://twitter.com/YaronNaveh).\n\n## Install\nInstall with [npm](http://github.com/isaacs/npm):\n\n    npm install xml-crypto\n\nA pre requisite it to have [openssl](http://www.openssl.org/) installed and its /bin to be on the system path. I used version 1.0.1c but it should work on older versions too.\n\n## Supported Algorithms\n\n### Canonicalization and Transformation Algorithms\n\n* Exclusive Canonicalization http://www.w3.org/2001/10/xml-exc-c14n#\n* Exclusive Canonicalization with comments http://www.w3.org/2001/10/xml-exc-c14n#WithComments\n* Enveloped Signature transform http://www.w3.org/2000/09/xmldsig#enveloped-signature\n\n### Hashing Algorithms\n\n* SHA1 digests http://www.w3.org/2000/09/xmldsig#sha1\n* SHA256 digests http://www.w3.org/2001/04/xmlenc#sha256\n* SHA512 digests http://www.w3.org/2001/04/xmlenc#sha512\n\n### Signature Algorithms\n\n* RSA-SHA1 http://www.w3.org/2000/09/xmldsig#rsa-sha1\n* RSA-SHA256 http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\n* RSA-SHA512 http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\n* HMAC-SHA1 http://www.w3.org/2000/09/xmldsig#hmac-sha1\n\nby default the following algorithms are used:\n\n*Canonicalization/Transformation Algorithm:* Exclusive Canonicalization http://www.w3.org/2001/10/xml-exc-c14n#\n\n*Hashing Algorithm:* SHA1 digest http://www.w3.org/2000/09/xmldsig#sha1\n\n*Signature Algorithm:* RSA-SHA1 http://www.w3.org/2000/09/xmldsig#rsa-sha1\n\n[You are able to extend xml-crypto with custom algorithms.](#customizing-algorithms)\n\n\n## Signing Xml documents\n\nWhen signing a xml document you can specify the following properties on a `SignedXml` instance to customize the signature process:\n\n- `sign.signingKey` - **[required]** a `Buffer` or pem encoded `String` containing your private key\n- `sign.keyInfoProvider` - **[optional]** a key info provider instance, see [customizing algorithms](#customizing-algorithms) for an implementation example\n- `sign.signatureAlgorithm` - **[optional]** one of the supported [signature algorithms](#signature-algorithms). Ex: `sign.signatureAlgorithm = \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"`\n- `sign.canonicalizationAlgorithm` - **[optional]** one of the supported [canonicalization algorithms](#canonicalization-and-transformation-algorithms). Ex: `sign.canonicalizationAlgorithm = \"http://www.w3.org/2001/10/xml-exc-c14n#WithComments\"`\n\nUse this code:\n\n`````javascript\n\tvar SignedXml = require('xml-crypto').SignedXml\t  \n\t  , fs = require('fs')\n\n\tvar xml = \"<library>\" +\n\t            \"<book>\" +\n\t              \"<name>Harry Potter</name>\" +\n\t            \"</book>\" +\n\t          \"</library>\"\n\n\tvar sig = new SignedXml()\n\tsig.addReference(\"//*[local-name(.)='book']\")    \n\tsig.signingKey = fs.readFileSync(\"client.pem\")\n\tsig.computeSignature(xml)\n\tfs.writeFileSync(\"signed.xml\", sig.getSignedXml())\n\n`````\n\nThe result will be:\n\n\n`````xml\n\t<library>\n\t  <book Id=\"_0\">\n\t    <name>Harry Potter</name>\n\t  </book>\n\t  <Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n\t    <SignedInfo>\n\t      <CanonicalizationMethod Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\" />\n\t      <SignatureMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\" />\n\t      <Reference URI=\"#_0\">\n\t        <Transforms>\n\t          <Transform Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\" />\n\t        </Transforms>\n\t        <DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\" />\n\t        <DigestValue>cdiS43aFDQMnb3X8yaIUej3+z9Q=</DigestValue>\n\t      </Reference>\n\t    </SignedInfo>\n\t    <SignatureValue>vhWzpQyIYuncHUZV9W...[long base64 removed]...</SignatureValue>\n\t  </Signature>\n\t</library>\n`````\n\nNote:\n\nTo generate a `<X509Data></X509Data>` element in the signature you must provide a key info implementation, see [customizing algorithms](#customizing-algorithms) for an example.\n\n## Verifying Xml documents\n\nWhen verifying a xml document you must specify the following properties on a ``SignedXml` instance:\n\n- `sign.keyInfoProvider` - **[required]** a key info provider instance containing your certificate, see [customizing algorithms](#customizing-algorithms) for an implementation example\n\nYou can use any dom parser you want in your code (or none, depending on your usage). This sample uses [xmldom](https://github.com/jindw/xmldom) so you should install it first:\n\n    npm install xmldom\n\nExample:\n\n`````javascript\n\tvar select = require('xml-crypto').xpath\n\t  , dom = require('xmldom').DOMParser\n\t  , SignedXml = require('xml-crypto').SignedXml\n\t  , FileKeyInfo = require('xml-crypto').FileKeyInfo  \n\t  , fs = require('fs')\n\n\tvar xml = fs.readFileSync(\"signed.xml\").toString()\n\tvar doc = new dom().parseFromString(xml)    \n\n\tvar signature = select(doc, \"/*/*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']\")[0]\n\tvar sig = new SignedXml()\n\tsig.keyInfoProvider = new FileKeyInfo(\"client_public.pem\")\n\tsig.loadSignature(signature.toString())\n\tvar res = sig.checkSignature(xml)\n\tif (!res) console.log(sig.validationErrors)\n`````\n\nif the verification process fails `sig.validationErrors` will have the errors.\n\nNote:\n\nThe xml-crypto api requires you to supply it separately the xml signature (\"&lt;Signature&gt;...&lt;/Signature&gt;\", in loadSignature) and the signed xml (in checkSignature). The signed xml may or may not contain the signature in it, but you are still required to supply the signature separately.\n\n\n## API\n\n### xpath\n\nSee [xpath.js](https://github.com/yaronn/xpath.js) for usage\n\n### SignedXml\n\nThe `SignedXml` constructor provides an abstraction for sign and verify xml documents. The object is constructed using `new SignedXml([idMode])` where:\n\n- `idMode` - if the value of `\"wssecurity\"` is passed it will create/validate id's with the ws-security namespace.\n\n*API*\n\nA `SignedXml` object provides the following methods:\n\nTo sign xml documents:\n\n- `addReference(xpath, [transforms], [digestAlgorithm])` - adds a reference to a xml element where:\n    - `xpath` - a string containing a XPath expression referencing a xml element\n    - `transforms` - an array of [transform algorithms](#canonicalization-and-transformation-algorithms), the referenced element will be transformed for each value in the array\n    - `digestAlgorithm` - one of the supported [hashing algorithms](#hashing-algorithms)\n- `computeSignature(xml, [options])` - compute the signature of the given xml where:\n    - `xml` - a string containing a xml document\n    - `options` - an object with the following properties:\n        - `prefix` - adds this value as a prefix for the generated signature tags\n        - `attrs` - a hash of attributes and values `attrName: value` to add to the signature root node\n        - `location` - customize the location of the signature, pass an object with a `reference` key which should contain a XPath expression to a reference node, an `action` key which should contain one of the following values: `append`, `prepend`, `before`, `after`\n- `getSignedXml()` - returns the original xml document with the signature in it, **must be called only after `computeSignature`**\n- `getSignatureXml()` - returns just the signature part, **must be called only after `computeSignature`**\n- `getOriginalXmlWithIds()` - returns the original xml with Id attributes added on relevant elements (required for validation), **must be called only after `computeSignature`**\n\nTo verify xml documents:\n\n- `loadSignature(signatureXml)` - loads the signature where:\n    - `signatureXml` - a string or node object (like an [xml-dom](https://github.com/jindw/xmldom) node) containing the xml representation of the signature\n- `checkSignature(xml)` - validates the given xml document and returns true if the validation was successful, `sig.validationErrors` will have the validation errors if any, where:\n    - `xml` - a string containing a xml document\n\n\n### FileKeyInfo\n\nA basic key info provider implementation using `fs.readFileSync(file)`, is constructed using `new FileKeyInfo([file])` where:\n\n- `file` - a path to a pem encoded certificate\n\nSee [verifying xml documents](#verifying-xml-documents) for an example usage\n\n\n## Customizing Algorithms\nThe following sample shows how to sign a message using custom algorithms.\n\nFirst import some modules:\n\n`````javascript\n\tvar SignedXml = require('xml-crypto').SignedXml\n\t  , fs = require('fs')\n`````\n\n\nNow define the extension point you want to implement. You can choose one or more.\n\nA key info provider is used to extract and construct the key and the KeyInfo xml section.\nImplement it if you want to create a signature with a KeyInfo section, or you want to read your key in a different way then the default file read option.\n`````javascript\n\t/**/\n\tfunction MyKeyInfo() {\n\t  this.getKeyInfo = function(key, prefix) {\n        prefix = prefix || ''\n        prefix = prefix ? prefix + ':' : prefix\n\t    return \"<\" + prefix + \"X509Data></\" + prefix + \"X509Data>\"\n\t  }\n\t  this.getKey = function(keyInfo) {\n\t    //you can use the keyInfo parameter to extract the key in any way you want      \n\t    return fs.readFileSync(\"key.pem\")\n\t  }\n\t}\n`````\n\nA custom hash algorithm is used to calculate digests. Implement it if you want a hash other than the default SHA1.\n\n`````javascript\n\tfunction MyDigest() {\n\n\n\t  this.getHash = function(xml) {    \n\t    return \"the base64 hash representation of the given xml string\"\n\t  }\n\n\t  this.getAlgorithmName = function() {\n\t    return \"http://myDigestAlgorithm\"\n\t  }\n\t}\n`````\n\nA custom signing algorithm. The default is RSA-SHA1\n`````javascript\n\tfunction MySignatureAlgorithm() {\n\n\t  /*sign the given SignedInfo using the key. return base64 signature value*/\n\t  this.getSignature = function(signedInfo, signingKey) {            \n\t    return \"signature of signedInfo as base64...\"\n\t  }\n\n\t  this.getAlgorithmName = function() {\n\t    return \"http://mySigningAlgorithm\"\n\t  }\n\n\t}\n`````\n\nCustom transformation algorithm. The default is exclusive canonicalization.\n\n`````javascript\n\tfunction MyTransformation() {\n\n\t  /*given a node (from the xmldom module) return its canonical representation (as string)*/\n\t  this.process = function(node) {\t  \t\n\t  \t//you should apply your transformation before returning\n\t    return node.toString()\n\t  }\n\n\t  this.getAlgorithmName = function() {\n\t    return \"http://myTransformation\"\n\t  }\n\t}\n`````\nCustom canonicalization is actually the same as custom transformation. It is applied on the SignedInfo rather than on references.\n\n`````javascript\n\tfunction MyCanonicalization() {\n\n\t  /*given a node (from the xmldom module) return its canonical representation (as string)*/\n\t  this.process = function(node) {\n\t    //you should apply your transformation before returning\n\t    return \"< x/>\"\n\t  }\n\n\t   this.getAlgorithmName = function() {\n\t    return \"http://myCanonicalization\"\n\t  }\n\t}\n`````\n\nNow you need to register the new algorithms:\n\n`````javascript\n\t/*register all the custom algorithms*/\n\n\tSignedXml.CanonicalizationAlgorithms[\"http://MyTransformation\"] = MyTransformation\n\tSignedXml.CanonicalizationAlgorithms[\"http://MyCanonicalization\"] = MyCanonicalization\n\tSignedXml.HashAlgorithms[\"http://myDigestAlgorithm\"] = MyDigest\n\tSignedXml.SignatureAlgorithms[\"http://mySigningAlgorithm\"] = MySignatureAlgorithm\n`````\n\nNow do the signing. Note how we configure the signature to use the above algorithms:\n\n`````javascript\n\tfunction signXml(xml, xpath, key, dest)\n\t{\n\t  var sig = new SignedXml()\n\n\t  /*configure the signature object to use the custom algorithms*/\n\t  sig.signatureAlgorithm = \"http://mySignatureAlgorithm\"\n\t  sig.keyInfoProvider = new MyKeyInfo()\n\t  sig.canonicalizationAlgorithm = \"http://MyCanonicalization\"\n\t  sig.addReference(\"//*[local-name(.)='x']\", [\"http://MyTransformation\"], \"http://myDigestAlgorithm\")\n\n\t  sig.signingKey = fs.readFileSync(key)\n\t  sig.addReference(xpath)    \n\t  sig.computeSignature(xml)\n\t  fs.writeFileSync(dest, sig.getSignedXml())\n\t}\n\n\tvar xml = \"<library>\" +\n\t            \"<book>\" +\n\t              \"<name>Harry Potter</name>\" +\n\t            \"</book>\"\n\t          \"</library>\"\n\n\tsignXml(xml,\n\t  \"//*[local-name(.)='book']\",\n\t  \"client.pem\",\n\t  \"result.xml\")\n`````\n\nYou can always look at the actual code as a sample (or drop me a [mail](mailto:yaronn01@gmail.com)).\n\n\n## X.509 / Key formats\nXml-Crypto internally relies on node's crypto module. This means pem encoded certificates are supported. So to sign an xml use key.pem that looks like this (only the begining of the key content is shown):\n\n\t-----BEGIN PRIVATE KEY-----\n\tMIICdwIBADANBgkqhkiG9w0...\n\t-----END PRIVATE KEY-----\n\nAnd for verification use key_public.pem:\n\n\t-----BEGIN CERTIFICATE-----\n\tMIIBxDCCAW6gAwIBAgIQxUSX...\n\t-----END CERTIFICATE-----\n\n**Converting .pfx certificates to pem**\n\nIf you have .pfx certificates you can convert them to .pem using [openssl](http://www.openssl.org/):\n\n\topenssl pkcs12 -in c:\\certs\\yourcert.pfx -out c:\\certs\\cag.pem\n\nThen you could use the result as is for the purpose of signing. For the purpose of validation open the resulting .pem with a text editor and copy from -----BEGIN CERTIFICATE----- to  -----END CERTIFICATE----- (including) to a new text file and save it as .pem.\n\n## Examples\n\n- [how to sign a root node](#) *coming soon*\n\n###how to add a prefix for the signature###\nUse the `prefix` option when calling `computeSignature` to add a prefix to the signature. \n`````javascript\nvar SignedXml = require('xml-crypto').SignedXml\t  \n  , fs = require('fs');\n\nvar xml = \"<library>\" +\n            \"<book>\" +\n              \"<name>Harry Potter</name>\" +\n            \"</book>\" +\n          \"</library>\";\n\nvar sig = new SignedXml();\nsig.addReference(\"//*[local-name(.)='book']\");\nsig.signingKey = fs.readFileSync(\"client.pem\");\nsig.computeSignature(xml,{\n  prefix: 'ds'\n});\n`````\n\n###how to specify the location of the signature###\nUse the `location` option when calling `computeSignature` to move the signature around. \nSet `action` to one of the following: \n- append(default) - append to the end of the xml document\n- prepend - prepend to the xml document\n- before - prepend to a specific node (use the `referenceNode` property)\n- after - append to specific node (use the `referenceNode` property)\n\n`````javascript\nvar SignedXml = require('xml-crypto').SignedXml\t  \n  , fs = require('fs');\n\nvar xml = \"<library>\" +\n            \"<book>\" +\n              \"<name>Harry Potter</name>\" +\n            \"</book>\" +\n          \"</library>\";\n\nvar sig = new SignedXml();\nsig.addReference(\"//*[local-name(.)='book']\");\nsig.signingKey = fs.readFileSync(\"client.pem\");\nsig.computeSignature(xml,{\n  location: { reference: \"//*[local-name(.)='book']\", action: \"after\" } //This will place the signature after the book element\n});\n\n`````\n*more examples coming soon*\n\n## Development\nThe test framework is [nodeunit](https://github.com/caolan/nodeunit). To run tests use:\n\n    $> npm test\n\n## More information\nVisit my [blog](http://webservices20.blogspot.com/) or my [twitter](http://twitter.com/#!/YaronNaveh)\n\n\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/yaronn/xml-crypto/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/yaronn/xml-crypto/issues"
  },
  "homepage": "https://github.com/yaronn/xml-crypto",
  "_id": "xml-crypto@0.8.4",
  "dist": {
    "shasum": "cd9c971ac3660330262e3b1aa76df106511bd005"
  },
  "_from": "xml-crypto@~0.8.0",
  "_resolved": "https://registry.npmjs.org/xml-crypto/-/xml-crypto-0.8.4.tgz"
}
